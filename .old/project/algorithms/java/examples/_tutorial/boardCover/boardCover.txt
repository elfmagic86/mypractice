3 
3 7 
#.....# 
#.....# 
##...## 
3 7 
#.....# 
#.....# 
##..### 
8 10 
########## 
#........# 
#........# 
#........# 
#........# 
#........# 
#........# 
##########

//////////////////////
H*W 크기의 게임판이 있습니다. 게임판은 검은 칸과 흰 칸으로 구성된 격자 모양을 하고 있는데 이 중 모든 흰 칸을 3칸짜리 L자 모양의 블록으로 덮고 싶습니다. 이 때 블록들은 자유롭게 회전해서 놓을 수 있지만, 서로 겹치거나, 검은 칸을 덮거나, 게임판 밖으로 나가서는 안 됩니다. 위 그림은 한 게임판과 이를 덮는 방법을 보여줍니다.

게임판이 주어질 때 이를 덮는 방법의 수를 계산하는 프로그램을 작성하세요.

입력

력의 첫 줄에는 테스트 케이스의 수 C (C <= 30) 가 주어집니다. 각 테스트 케이스의 첫 줄에는 2개의 정수 H, W (1 <= H,W <= 20) 가 주어집니다. 다음 H 줄에 각 W 글자로 게임판의 모양이 주어집니다. # 은 검은 칸, . 는 흰 칸을 나타냅니다. 입력에 주어지는 게임판에 있는 흰 칸의 수는 50 을 넘지 않습니다.

출력

한 줄에 하나씩 흰 칸을 모두 덮는 방법의 수를 출력합니다.

예제 입력
 // 위.
 
예제 출력

0
2
1514

///// 풀이
 1) 한열씩 순차적으로 탐색함. 가능한 칸에 대해서 작업을 블락 커버하는 작업을하고. 만약 블락커버되지 못하면. 리턴 0;
   -> 즉..발견한 사용가능한 칸은 블락으로 커버가능해야해. 하나라도 안된다면 그 경로는 실패 경로야.
   
 2) 깊이우선탐색... 
   ; 블락으로 덮을수 있는 모든 가능한 경로  = blockCover(curPosition, curBoard)
   							   = sum{ for( 블락 in 현재위치에 대해 가능한 블락들)  // 없으면 return 0 ;
   							   			보드에 블락을 덮는다. //보드가 변경됨.
   							   			blockCover(nextPosition, nextBoard) //가능하면..1씩 sum에 축적됨.
   							   			위에서 덮은 블락을 취소.
   							        }
   							        
  3) 블락은.. 열탐색에서 무시되지 않고 모두 허용가능하도록
     ㄱ, ㄴ, ㄱ(오른쪽과, 오른쪽위), ㄱ(오른쪽과, 아래)  //현재점기준.        