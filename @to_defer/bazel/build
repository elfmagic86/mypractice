
- 기본명령

```
# ProjectRunner is what we named that target in the BUILD file.
bazel build //:ProjectRunner

bazel build //src/main/java/com/example/cmdline:runner
```


- 실행파일
의존성을 포함하여 실행가능한 wrapper script
디버그 모드로(`bash -x ./ProjectRunner`) 실행하여 아래와 같은 구조 확인
java -classpath A.jar:B.jar com.example.ProjectRunner

- 문법

	- 도움말: `bazel help target-syntax`

	- //
	  - the // part is the location of our BUILD file relative to the root of the workspace
	  - //가 없을시 cwd기준 위치를 기준으로 //를 붙인것과 동등포현 (//cwd/package-name)

	- //path/to/package:target-name
	  - 패키지가 있는 폴더에는 BUILD파일이 존재함
	  - target-name는 BUILD파일에 정의된 타겟명
	  - :target-name 생략시 package이름이 target-name으로 사용됨

	- These two may be combined, as in foo/...:all, and when both wildcards are used, this may be abbreviated to foo/....
		- foo/... is a wildcard over packages, indicating all packages recursively beneath directory foo (for all roots of the package path).
		- :all is a wildcard over targets, matching all rules within a package.
		- :* TODO


- deps의 target참조
	- When referencing targets within the same package, you can skip the package path
	  and just use //:target-name.

	  - 해당케이스 어떤상황일까. 패키지내의 서브패키지를 의미하는것일까.

	- When referencing targets within the same BUILD file,
	  you can even skip the // workspace root identifier and just use :target-name.

- 빌드결과물
	- If the target is a file target, then path/to/package is the path to the root of the package,
	  and target-name is the name of the target file, including its full path.


- Evaluation model(평가 모델)
A build consists of three phases(단계)

	- Loading phase.
		First, we load and evaluate(평가) all extensions and all BUILD files
		that are needed for the build.
		The execution(실행) of the BUILD files simply instantiates rules
		(each time a rule is called, it gets added to a graph).
		This is where macros are evaluated.
		BUILD 파일을 실행하면 규칙이 간단하게 인스턴스화됩니다.
		- (규칙이 호출 될 때마다 그래프에 추가됩니다).
		- 이것은 매크로가 평가되는 곳입니다.

	- Analysis(분석) phase.
		- The code of the rules is executed (their implementation function)
			and actions are instantiated.
		An action describes how to generate a set of outputs from a set of inputs,
		e.g. “run gcc on hello.c and get hello.o”.
		It is important to note that we have to list explicitly which files will be
		generated before executing the `actual commands`.
		In other words,
		the analysis phase takes the graph generated by the loading phase
		- and `generates an action graph`.

	- Execution phase.
		- Actions are executed,
		when at least one of their outputs is required.
		If a file is missing or if a command fails to generate one output,
		the build fails.
		- Tests are also run during this phase.

		Bazel uses parallelism to read, parse and evaluate the .bzl files and BUILD
		files.
		A file is read at most once per build and the result of the evaluation
		is cached and reused.
		A file is evaluated only once all its dependencies
		(load() statements) have been resolved.
		By design, loading a .bzl file has no visible side-effect,
		- it only defines values and functions.


	- Bazel tries to be clever:
	it uses dependency analysis to know which files must be loaded,
		- which rules must be analyzed, and which actions must be executed.
		For example, if a rule generates actions that we don’t need for the current
		build, they will not be executed.
