# TheadsLocks 챕터

	#
		- 자바의 동시성 기본단위는 스레드
		스레드는 공유 메모리를 이용해 다른 스레드와 통신

		- 자바에서는 모든 객체가 저마다의 잠금장치를 가지고 있다.(데드락위험)

		- 자바메모리 모델

			- http://www.cs.umd.edu/~pugh/java/memoryModel/
				- 동기화 블록에서 빠져나온뒤 우리는 모니터를 해제(release)합니다. 이때 캐시 메모리의 데이터를 메인 메모리로 이동시키며 쓰레드의 메모리 쓰기(writes) 연산들은 다른 쓰레드에게 보여지게 됩니다
				  쓰레드는 동기화 블록에 들어가기전에 모니터를 획득(acquire)합니다. 이 모니터는 메인 로컬 캐시를 무효화 시키며 메인 메모리로부터 다시 데이터를 불러옵니다. 결국 이전에 수행된 모든 쓰기 연산을 볼 수 있게 됩니다.

				- 해제(release)와 획득(acquire)은 같은 모니터에서 실행되어야 합니다. 그렇지 않으면 데이터 레이스(data race)가 발생합니다.

				- ?final
				- Volatile 필드는 쓰레드간에 상태를 공유하기 위해 사용되는 필드입니다. 각각의 읽기 연산은 마지막으로 어떤 쓰레드에서 수행된 쓰기 연산의 결과를 볼 수 있습니다
				  volatile에 쓰기 연산은 모니터 해제와 같은 메모리 수준의 효과를 갖고 읽기 연산은 모니터 획득과 같은 효과를 갖습니다

				- ?On Demand Holder 초기화

			- http://parkcheolu.tistory.com/14
				- 스태틱 클래스 변수 또한 클래스 정의와 함께 힙에 저장된다.
				- 자바 메모리모델과 하드웨어 메모리 아키텍처 연결그림
				:
					- 공유 변수에 대한 쓰레드의 업데이트(쓰기 작업)의 가시성
					- 공유 변수에의 읽기, 확인(checking), 쓰기 작업의 경합 조건

			- http://qwefgh90.github.io/java/JSR-133-(Java-Memory-Model)-FAQ(%EB%B2%88%EC%97%AD)/
				- 강한/약한 메모리모델

		- Double-Checked Locking Pattern을 쓰지 말아야 하는 이유
			- https://m.blog.naver.com/PostView.nhn?blogId=jjoommnn&logNo=130036635345&proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F
			- https://m.blog.naver.com/PostView.nhn?blogId=jjoommnn&logNo=130036640859&referrerCode=0&searchKeyword=Double

		- volatile
		http://blog.javarouka.me/2012/04/volatile-keyword-in-java.html
			- 특정 변수에 대한 읽기 작업은 반드시 메인 메모리로부터 수행하고, 쓰기 작업은 항상 메인 메모리에 즉각 반영하도록 강제할 수 있다.
			- 컴파일러의 코드 재배열 회피

	# 멀티스레드 코드가 잘못된 수 있는 경우

		- 경쟁조건
			- 풀이
			자바객체에 포함되어있는 내재된 잠금장치(intrinsic lock)사용
			용어: 내재된 잠금장치(때로 뮤텍스(mutex), 모니터(monitor), 혹은 임계영역(critical section)이라 불리는)



		- 메모리 가시성: 메모리 미스터리(Puzzle참고)
		: 결과가 "The meaning of life is: 0"이 된다?

			- 코드 실행순서 변경 가능성
				- 컴파일러의 정적최적화
				- JVM의 동적최적화
				- 코드를 실행하는 하드웨어가 순서 변경함


			- 자바 메모리 모델(미스터리해결을위한규칙
			: 자바 메모리 모델은 한 스레드가 메모리에 가한 변화가 다른 메모리에 보이는 경우를 정의
			!! 읽는 스레드와 쓰는 스레드가 동기화되지 않으면 그러한 가시성 보장되지않음

				코드상에서, 쓰기뿐 아니라 읽기동작도 동기화(잠금장치등으로)되어야 한다
				그렇지 않으면 어떤 스레드는 오래된 어떤값을 읽게됨

		- 데드락(식사하는철학자 참고)
		둘 이상의 잠금장치를 요구하는 경우

			- 데드락케이스
			동시식사 + 모두가 왼쪽젓가락(잠금장치1) 들어올림
			모두가 우측젓가락(잠금장치2)를 영원히 기다림

			- 처리
			두젓가락(잠금장치1,2)에 순서를 줌
			ex) 철학자(0,1), 철학자(1,2)...철학자(4,0) -> 철학자(0,1), 철학자(1,2)...철학자(0,4)


		- 데드락(HttpDownload참조)
		잠금장치 보유상태에서 외부메서드 호출하는 경우

			- 데드락 케이스
			만약 외부 메서드가 잠금장치를 요청한다면 위의 철학자문제처럼 두개의 잠금장치를 요청하게됨
			데드락의 위험성은 둘이상의 잠금장치를 손에 넣으려고 할때 반드시 존재함.

			- 처리
			어떤 잠금장치를 보유하고 있는 상태에서는 외부 메서드를 호출하지 않는다.(둘 -> 한개)
			방어적 복제(HttpDownloadFixed참조)




