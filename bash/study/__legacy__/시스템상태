// -----------------------
// 하드웨어
// -----------------------
## 하드웨어정보 ; lscpu

## os정보 : uname -a
  ; 근데 x86_64는 뭐지? 32비트여..64비트여.. cpu가 두개니 둘다 적응되는버전인가? cpu가 각각 다른가?

## 디스크 용량.
: df -h


## 메모리
: free
: cat /proc/meminfo

// -----------------------
// 프로세스.
// -----------------------


## 프로세스추적.  // htop 엄청좋은데?
: ps는 현재 실행중인 프로세스를 열거.
: top는 ps내용 + 현재 시스템상태도 보여줌. // 최상단에 가장활동적 프로세스보여줌.(cpu사용)
  : 키입력으로(키스트로크) 특정 명령을 top에 전송할수있음. (space는 즉각적 화면업뎃)
  : 컬럼내용
    :: PR(process priority), NI(nice value: ㅋ커널스케줄러에 힌트를줌(우선순위에대해서))

: atop, htop   (top 확장)


## 열려있는 파일(네트워크 리소스, 동적 라이브러리, 파이프등도 가능)과 그 파일들을 사용하는 프로세스들을 열거.
: lsof

## 시스템콜 추적: strace

## 라이브러리 추적: ltrace

## 스레드.
:ps m
  : pid가 대시(-)인 것. 프로세스와 관있는 스레드임.(보통 메인스레드 한개임)

## 특정 프로세스 cpu시간측정 by pid : top -p pid1 [-p pid2]

## 특정명령 지속시간. : time[/usr/bin/time] 명령어
: user: cpu가 프로그램자체코드를 실행하는시간
: system: 커널이 프로세스의 작업(파일읽기 같은)하는 데 걸리는 식나
: elapsed: 시작-종료까지 전체시간.  
: elapsed - user - system = 프로세스가 시스템리소스를기다리는데 보낸시간.(대략)

## 부하평균
: 주어진 시간에 CPU를 사용할수있는 프로세스들의 수.를 추산한ㄴ 값..
: 실제뭔가를 하고잇는 프로세스만 영향을줌.(대부분은 실행준비가되징낳았음.: 대게 입력을 기다리기에(키보드,마우스,네트워크등으로 부터))

: uptime
  :각 1분, 5분, 15분의 부하평균이고.   0.01의 의미는 코어  1개대상으로 1%사용했다는의미.(2개면 2까지올라가겟지)
  :부하평균이 대략1까지 올라간다면 top으로 현재 프로세스확인하룻있음. 


## 페이지부재 상세 검토.
 - time사용
one@LG-R570-GE2WK:~$ /usr/bin/time cal > /dev/null
0.00user 0.00system 0:00.00elapsed 0%CPU (0avgtext+0avgdata 2492maxresident)k
0inputs+0outputs (0major+105minor)pagefaults 0swaps //주요페이지부재, 사소한페이지부재 상태임.

 - top(f로 보여질컬럼 수정할수있는데, pagefault컬럼이있당)

 - ps사용
one@LG-R570-GE2WK:~$ ps -o pid,min_flt,maj_flt 1   //1은 root의 pid, -o다음은 보고싶은컬럼명.
  PID  MINFL  MAJFL
    1  65162     29

## cpu메모리 성능검토 by vmstat  //해석이 까다로움. p225~6참조
:swpd 에서, 처음된 swap크기를 알수있음.
그리고 si so컬럼으로, 이후 swap을 하는지 알수있지. //디스크로 교체하는지.
:buff //커널이 디스크버퍼를위해 사용중인 메모리양.   



## I/O 모니터링 by iostat
:iostat -p ALL //장치외 파티션정보까지. //단 디스크의 파티션 중 중복되는것이있을것이기에 파티션합이 디스크인것은아님.

## 프로세스별 I/O 활용, 모니터링 by iotop
: TID. 프로세스대신 스레드를보여줌.

## 프로세스별 모니터링: pidstat
: top같은애들은 시간에 따라 기록이 소실됨. vmstat과 같은 시간의 흐름에따라 소실된 프로세스의 리소스를 볼수있게해줌.
: pidstat -p 1 1(초)  
: -r옵션으로 메모리모니터링도 가능.
: -d는 디스크.


--------------------기타
_)주문형 페이지(on-demand paging or demand paging)
: 프로세스들이 페이지를 필요로 할때ㅐ, (보통) 커널이 페이지를 로딩하고 할당한다.

_)프로그램이 새로운 프로세스로 시작, 실행방법.
1. 커널은 프로그램 명령코드의 시작부분을 메모리페이지로 로딩.
2. 커널은 새 프로세스에 작업메모리 페이지를 일부 할당.
3. 프로세스 실행됨에따라, 커널이 처음 로딩한 코드상의 다음명령을 페이지상에서 찾을수없는 지점에 이를것이다.
이시점에 커널이 나서서 필요한 페이지들을 메모리로 로딩하고, 프로그램이 실행을 재개하도록함.
4. 유사방ㅂ식으로, 만약 프로그램이 초기 할당했던 것보다ㅏㅏ더 많은 작업메모리를 요구한다면, 
커널은 작업이 없는 페이지를 찾거나, 공간을 마련하여 프로세스에 이 페이지들을 할당함.

_)MMU
: CPU가소유. 프로세스들이 사용하는 가상메모리주소 -> 실주소로.
: 커널은 프로세스에 의해 사용된 메모리를 페이지, 라는 작은 단위로 분ㅇ리하여 MMU를도움.
: 커널은 페이지테이블,
을 유지하여, 가상페이지주소-> 메모리상의 실페이지주소로 매핑하는 기능을 가짐. 즉 MMU가 커널의 페이지테이블을 기반으로 주소변경작업을하는것.

_)page fault
: 프로세스가 페이지를 사용하기 원하는데, 메모리 페이지가 준비되지 않았을경우 발생.
  이때, 커널은 페이지준비를위해 프로세스들로 부터 CPU의 통제권을가져옴.

  - 사소한 페이지부재.
  : 요구되는 페이지가 사실 메모리상에있지만, 그위치파악을못할때.발생.(프로세스가 더많은 메모리요청하거나, MMU가 프로세스의 모든페이지를 위한장소저장할만큼 충분한공간없을경우.)
    :: 커널은 MMU에 페이지에 대해 전달하고, 프로세스가지속되도록허용.

  - 중대한페이지부재.
  : 필요메모리페이지가 메모리상엦 전혀없을때.발생.
    :: 커널이 디스크 혹은 좀더느린저장장치로부터 로딩해야함.
       이작업이 많이 발생할경우. 시스템이 교착상태에 빠질수있음. 커널이 페이지제공위해 상당작업을하고, 이로인해 일반프로세스들은 실행할기회를 잃기때문.
       ::: 가장크게 문제될때는 작업메모리의 페이지들을 디스크로 교체하기시작할때임.
  
