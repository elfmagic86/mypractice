# bit_operator

- N << X
N을 2진수로 표현할때.타입의 크기에 맞게 자릿수를 고정 후 0으로 채워줘야함
	- 5 << 2 계산과정
	 N을 4bit로 가정: 0101
	 00을 추가: 010100
	 네자릿수유지: 0101

	`>>`도 유사 절차

- 큰수 계산이 범위가 넘음에도 가능한 이유?
	ex: `uint64(1<<64 - 1)`에서 1<<64는 int64범위가 넘는데 계산(-1)이 됨
	유사로, `1<<70 -1`, `1267650600228229401496703205375 - 1`도 overflow int 에러나는 나지만 계산은 됨

	=> 표현식의 계산을 기계어 수준으로 볼때,
	타입제한없는 메모리 값과 cpu연산으로 생각할 수 있으므로 가능함
	다만, 결과값 타입에 담을때는 범위가 초과될 수 있으므로 overflow가 생김

todo: - and, or, xor 등
	  - sined / unsined 차이
	  - >>> <<<


- min := int(^uint(0) >> 1)  // largest int

- 1<<64 - 1 에 대해

```
gore> test := uint64(1<<64 - 1)
0xffffffffffffffff
gore>
gore> fmt.Printf("%x   %d", test, test)
ffffffffffffffff   1844674407370955161539
```

	- shift연산
	ex) 1			 => 1<<4
		00001(2진수) => 10000(2진수)
		0x1(16진수)  => 0x10(16진수) // go에선 0x를 붙여 16진수표현
		01(8진수)	 => 020(8진수) // go에선 0을 붙여 8진수 표현
		1(10진수)    => 16(10진수)

	- unsined int(64)의 최대값에 대해
		- 64비트는 1과0으로 서로 다른 2^64가지를 표현 가능(ex: 0000, 0001, 0002 .....)
		- 숫자 범위로 표현시 1 <= N <= 2^64 or 0<= N <= 2^64 - 1의 범위를 표현 가능함
		- 숫자표현은 0을 포함하므로 후자를 사용한다.
		  그렇기에 uint64의 최대값은 2^64 - 1 이 됨.

	- 1byte = 8bit
		- 1bit = 2, 4bit = 16, 8bit = 256(2^8) 가지 표현
		- 00000000 ~ 11111111 // 2^8 - 1
		  0x00 ~ 0xff // 16진수: 2^4 * 2^4 - 1
		  00000 ~ 01000>>1 -1 // 8진수: 2^3 * 2^3 * 2^3 / 2 - 1

